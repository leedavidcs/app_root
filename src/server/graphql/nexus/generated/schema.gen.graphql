### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input AddressInput {
  city: String
  country: String
  line1: String!
  state: String
  zipcode: String
}

type Balance {
  credits: Int!
  user: User!
}

input BalanceCreateManyWithoutUserInput {
  connect: [BalanceWhereUniqueInput!]
  create: [BalanceCreateWithoutUserInput!]
}

input BalanceCreateWithoutUserInput {
  credits: Int
}

input BalanceFilter {
  every: BalanceWhereInput
  none: BalanceWhereInput
  some: BalanceWhereInput
}

input BalanceScalarWhereInput {
  AND: [BalanceScalarWhereInput!]
  credits: IntFilter
  NOT: [BalanceScalarWhereInput!]
  OR: [BalanceScalarWhereInput!]
  userId: StringFilter
}

input BalanceUpdateManyDataInput {
  credits: Int
}

input BalanceUpdateManyWithoutUserInput {
  connect: [BalanceWhereUniqueInput!]
  create: [BalanceCreateWithoutUserInput!]
  delete: [BalanceWhereUniqueInput!]
  deleteMany: [BalanceScalarWhereInput!]
  disconnect: [BalanceWhereUniqueInput!]
  set: [BalanceWhereUniqueInput!]
  update: [BalanceUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [BalanceUpdateManyWithWhereNestedInput!]
  upsert: [BalanceUpsertWithWhereUniqueWithoutUserInput!]
}

input BalanceUpdateManyWithWhereNestedInput {
  data: BalanceUpdateManyDataInput!
  where: BalanceScalarWhereInput!
}

input BalanceUpdateWithoutUserDataInput {
  credits: Int
}

input BalanceUpdateWithWhereUniqueWithoutUserInput {
  data: BalanceUpdateWithoutUserDataInput!
  where: BalanceWhereUniqueInput!
}

input BalanceUpsertWithWhereUniqueWithoutUserInput {
  create: BalanceCreateWithoutUserInput!
  update: BalanceUpdateWithoutUserDataInput!
  where: BalanceWhereUniqueInput!
}

input BalanceWhereInput {
  AND: [BalanceWhereInput!]
  credits: IntFilter
  NOT: [BalanceWhereInput!]
  OR: [BalanceWhereInput!]
  user: UserWhereInput
  userId: StringFilter
}

input BalanceWhereUniqueInput {
  userId: String
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""The provider for the data provided by the data key"""
enum DataKey_Provider {
  """IEX Cloud (see `https://iexcloud.io/`)"""
  IEX_CLOUD
}

"""
A single data key option that can be selected for a stock portfolio header
"""
type DataKeyOption {
  """A unique data key for fetching stock portfolio data"""
  dataKey: String!

  """A more normal name. This can be shown to users."""
  name: String!

  """The name of the provider"""
  provider: DataKey_Provider!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

enum Day {
  Fri
  Mon
  Sat
  Sun
  Thurs
  Tues
  Wed
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

type FeaturePricing {
  snapshot: FeaturePricingConfig!
}

type FeaturePricingConfig {
  price: Int!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input LoginLocalUserInput {
  """The user's decrypted password"""
  password: String!

  """The email or username (either) of the user"""
  userIdentifier: String!
}

"""Root mutation type"""
type Mutation implements RequestRoot {
  applySucceededTransaction(paymentIntentId: String!): Balance
  cancelStripeSetupIntent(id: String!): StripeSetupIntent
  cancelTransaction(paymentIntentId: String!): Balance
  createOneStockPortfolio(data: StockPortfolioCreateInput!): StockPortfolio!
  createOneStockPortfolioEvent(data: StockPortfolioEventCreateInput!): StockPortfolioEvent!
  createOneWebhook(data: WebhookCreateInput!): Webhook!
  createStripePaymentIntent(orderDetails: [OrderDetailInput!]!, paymentMethodId: String!): StripePaymentIntent
  createStripeSetupIntent: StripeSetupIntent
  deleteOneStockPortfolio(where: StockPortfolioWhereUniqueInput!): StockPortfolio
  deleteOneWebhook(where: WebhookWhereUniqueInput!): Webhook

  """Logins in the user, and returns an expiring access token"""
  loginLocalUser(input: LoginLocalUserInput!): TokenPayload

  """Refreshes the currently logged-in user's access token"""
  refreshAccessToken(input: RefreshAccessTokenInput!): TokenPayload

  """Performs local auth registration (custom username + password)"""
  registerLocalUser(input: RegisterLocalUserInput!): RegisterLocalUserPayload

  """Resends the account verification email to the logged-in user"""
  resendVerifyEmail: ResendVerifyEmailPayload
  updateOneStockPortfolio(data: StockPortfolioUpdateInput!, where: StockPortfolioWhereUniqueInput!): StockPortfolio
  updateOneStockPortfolioEvent(data: StockPortfolioEventUpdateInput!, where: StockPortfolioEventWhereUniqueInput!): StockPortfolioEvent
  updateOneStockPortfolioSettings(data: StockPortfolioSettingsUpdateInput!, where: StockPortfolioSettingsWhereUniqueInput!): StockPortfolioSettings
  updateOneWebhook(data: WebhookUpdateInput!, where: WebhookWhereUniqueInput!): Webhook

  """The viewer of this request"""
  viewer: User
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

input OrderDetailInput {
  id: String!
  quantity: Int = 1
  type: OrderDetailType!
}

enum OrderDetailType {
  PriceBundle
}

type PriceBundle {
  credits: Int!
  id: String!
  price: Float!
}

"""Root query type"""
type Query implements RequestRoot {
  balance(where: BalanceWhereUniqueInput!): Balance

  """
  Retrieves the list of data key options for a stock portfolio header. All filters are 		OR'ed.
  """
  dataKeyOptions(
    """Filter by dataKey (partial works)"""
    dataKey: String

    """Filter by name (partial works)"""
    name: String

    """Filter by provider (partial works)"""
    provider: String
  ): [DataKeyOption!]!
  featurePricing: FeaturePricing!
  priceBundles: [PriceBundle!]!
  snapshot(where: SnapshotWhereUniqueInput!): Snapshot
  snapshots(after: SnapshotWhereUniqueInput, before: SnapshotWhereUniqueInput, first: Int, last: Int, orderBy: SnapshotOrderByInput, skip: Int, where: SnapshotWhereInput): [Snapshot!]!
  stockData(where: StockDataWhereUniqueInput!): StockData
  stockPortfolio(where: StockPortfolioWhereUniqueInput!): StockPortfolio
  stockPortfolioCount(query: String, where: StockPortfolioWhereInput): Int
  stockPortfolios(after: StockPortfolioWhereUniqueInput, before: StockPortfolioWhereUniqueInput, first: Int, last: Int, orderBy: StockPortfolioOrderByInput, query: String, skip: Int, where: StockPortfolioWhereInput): [StockPortfolio!]!
  stockSymbols(text: String!): [StockDataSearch!]!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(after: TransactionWhereUniqueInput, before: TransactionWhereUniqueInput, first: Int, last: Int, skip: Int, where: TransactionWhereWithoutUserInput): [Transaction!]!

  """The viewer of this request"""
  viewer: User
  webhook(where: WebhookWhereUniqueInput!): Webhook
  webhookCount(where: WebhookWhereInput): Int!
  webhooks(after: WebhookWhereUniqueInput, before: WebhookWhereUniqueInput, first: Int, last: Int, orderBy: WebhookOrderByInput, skip: Int, where: WebhookWhereInput): [Webhook!]!
}

input RefreshAccessTokenInput {
  """The refresh token, that is used to refresh the access token"""
  refreshToken: String!
}

input RegisterLocalUserInput {
  """(Unique) The user's email"""
  email: EmailAddress!

  """The user's decrypted password"""
  password: UserPassword!

  """(Unique) The user's username"""
  username: String!
}

"""The response object from a local register user request"""
type RegisterLocalUserPayload {
  """An error will be described if success is false"""
  error: String

  """Whether the registration successfully created a user or not"""
  success: Boolean!

  """The user object"""
  user: User
}

"""Common properties for Query, Mutation and Subscription types"""
interface RequestRoot {
  """The viewer of this request"""
  viewer: User
}

"""The response object from a resend verify email request"""
type ResendVerifyEmailPayload {
  """Status, on whether the email was successfully resent"""
  success: Boolean!
}

type ScheduledEvent {
  days: [Day!]!
  hour: Int
  id: String!
  interval: Int
  minute: Int
  next: DateTime!
  stockPortfolioEvent: StockPortfolioEvent
  timezone: String!
  user: User!
}

input ScheduledEventCreatedaysInput {
  set: [Day!]
}

input ScheduledEventCreateManyWithoutUserInput {
  connect: [ScheduledEventWhereUniqueInput!]
  create: [ScheduledEventCreateWithoutUserInput!]
}

input ScheduledEventCreateOneWithoutStockPortfolioEventInput {
  create: ScheduledEventCreateWithoutStockPortfolioEventInput!
}

input ScheduledEventCreateWithoutStockPortfolioEventInput {
  days: ScheduledEventCreatedaysInput
  hour: Int
  interval: Int
  minute: Int
  timezone: String
}

input ScheduledEventCreateWithoutUserInput {
  days: ScheduledEventCreatedaysInput
  hour: Int
  id: String
  interval: Int
  minute: Int
  next: DateTime
  stockPortfolioEvent: StockPortfolioEventCreateManyWithoutScheduledEventInput
  timezone: String
}

input ScheduledEventFilter {
  every: ScheduledEventWhereInput
  none: ScheduledEventWhereInput
  some: ScheduledEventWhereInput
}

input ScheduledEventScalarWhereInput {
  AND: [ScheduledEventScalarWhereInput!]
  hour: NullableIntFilter
  id: StringFilter
  interval: NullableIntFilter
  minute: NullableIntFilter
  next: DateTimeFilter
  NOT: [ScheduledEventScalarWhereInput!]
  OR: [ScheduledEventScalarWhereInput!]
  stockPortfolioEvent: StockPortfolioEventFilter
  timezone: StringFilter
  userId: StringFilter
}

input ScheduledEventUpdatedaysInput {
  set: [Day!]
}

input ScheduledEventUpdateManyDataInput {
  days: ScheduledEventUpdatedaysInput
  hour: Int
  id: String
  interval: Int
  minute: Int
  next: DateTime
  timezone: String
}

input ScheduledEventUpdateManyWithoutUserInput {
  connect: [ScheduledEventWhereUniqueInput!]
  create: [ScheduledEventCreateWithoutUserInput!]
  delete: [ScheduledEventWhereUniqueInput!]
  deleteMany: [ScheduledEventScalarWhereInput!]
  disconnect: [ScheduledEventWhereUniqueInput!]
  set: [ScheduledEventWhereUniqueInput!]
  update: [ScheduledEventUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ScheduledEventUpdateManyWithWhereNestedInput!]
  upsert: [ScheduledEventUpsertWithWhereUniqueWithoutUserInput!]
}

input ScheduledEventUpdateManyWithWhereNestedInput {
  data: ScheduledEventUpdateManyDataInput!
  where: ScheduledEventScalarWhereInput!
}

input ScheduledEventUpdateOneRequiredWithoutStockPortfolioEventInput {
  connect: ScheduledEventWhereUniqueInput
  create: ScheduledEventCreateWithoutStockPortfolioEventInput
  update: ScheduledEventUpdateWithoutStockPortfolioEventDataInput
  upsert: ScheduledEventUpsertWithoutStockPortfolioEventInput
}

input ScheduledEventUpdateWithoutStockPortfolioEventDataInput {
  days: ScheduledEventUpdatedaysInput
  hour: Int
  id: String
  interval: Int
  minute: Int
  next: DateTime
  timezone: String
  user: UserUpdateOneRequiredWithoutScheduledEventInput
}

input ScheduledEventUpdateWithoutUserDataInput {
  days: ScheduledEventUpdatedaysInput
  hour: Int
  id: String
  interval: Int
  minute: Int
  next: DateTime
  stockPortfolioEvent: StockPortfolioEventUpdateManyWithoutScheduledEventInput
  timezone: String
}

input ScheduledEventUpdateWithWhereUniqueWithoutUserInput {
  data: ScheduledEventUpdateWithoutUserDataInput!
  where: ScheduledEventWhereUniqueInput!
}

input ScheduledEventUpsertWithoutStockPortfolioEventInput {
  create: ScheduledEventCreateWithoutStockPortfolioEventInput!
  update: ScheduledEventUpdateWithoutStockPortfolioEventDataInput!
}

input ScheduledEventUpsertWithWhereUniqueWithoutUserInput {
  create: ScheduledEventCreateWithoutUserInput!
  update: ScheduledEventUpdateWithoutUserDataInput!
  where: ScheduledEventWhereUniqueInput!
}

input ScheduledEventWhereInput {
  AND: [ScheduledEventWhereInput!]
  hour: NullableIntFilter
  id: StringFilter
  interval: NullableIntFilter
  minute: NullableIntFilter
  next: DateTimeFilter
  NOT: [ScheduledEventWhereInput!]
  OR: [ScheduledEventWhereInput!]
  stockPortfolioEvent: StockPortfolioEventFilter
  timezone: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

input ScheduledEventWhereUniqueInput {
  id: String
}

type Snapshot {
  data: [JSONObject!]!
  headers: [SnapshotHeader!]!
  id: String!
  stockPortfolio: StockPortfolio!
  tickers: [String!]!
}

input SnapshotCreatedataInput {
  set: [String!]
}

input SnapshotCreateheadersInput {
  set: [String!]
}

input SnapshotCreateManyWithoutStockPortfolioInput {
  connect: [SnapshotWhereUniqueInput!]
  create: [SnapshotCreateWithoutStockPortfolioInput!]
}

input SnapshotCreatetickersInput {
  set: [String!]
}

input SnapshotCreateWithoutStockPortfolioInput {
  createdAt: DateTime
  data: SnapshotCreatedataInput
  headers: SnapshotCreateheadersInput
  id: String
  tickers: SnapshotCreatetickersInput
}

input SnapshotFilter {
  every: SnapshotWhereInput
  none: SnapshotWhereInput
  some: SnapshotWhereInput
}

type SnapshotHeader implements StockPortfolioDataHeader {
  dataKey: String!
  name: String!
}

input SnapshotOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  stockPortfolioId: OrderByArg
}

input SnapshotScalarWhereInput {
  AND: [SnapshotScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [SnapshotScalarWhereInput!]
  OR: [SnapshotScalarWhereInput!]
  stockPortfolioId: StringFilter
}

input SnapshotUpdatedataInput {
  set: [String!]
}

input SnapshotUpdateheadersInput {
  set: [String!]
}

input SnapshotUpdateManyDataInput {
  createdAt: DateTime
  data: SnapshotUpdatedataInput
  headers: SnapshotUpdateheadersInput
  id: String
  tickers: SnapshotUpdatetickersInput
}

input SnapshotUpdateManyWithoutStockPortfolioInput {
  connect: [SnapshotWhereUniqueInput!]
  create: [SnapshotCreateWithoutStockPortfolioInput!]
  delete: [SnapshotWhereUniqueInput!]
  deleteMany: [SnapshotScalarWhereInput!]
  disconnect: [SnapshotWhereUniqueInput!]
  set: [SnapshotWhereUniqueInput!]
  update: [SnapshotUpdateWithWhereUniqueWithoutStockPortfolioInput!]
  updateMany: [SnapshotUpdateManyWithWhereNestedInput!]
  upsert: [SnapshotUpsertWithWhereUniqueWithoutStockPortfolioInput!]
}

input SnapshotUpdateManyWithWhereNestedInput {
  data: SnapshotUpdateManyDataInput!
  where: SnapshotScalarWhereInput!
}

input SnapshotUpdatetickersInput {
  set: [String!]
}

input SnapshotUpdateWithoutStockPortfolioDataInput {
  createdAt: DateTime
  data: SnapshotUpdatedataInput
  headers: SnapshotUpdateheadersInput
  id: String
  tickers: SnapshotUpdatetickersInput
}

input SnapshotUpdateWithWhereUniqueWithoutStockPortfolioInput {
  data: SnapshotUpdateWithoutStockPortfolioDataInput!
  where: SnapshotWhereUniqueInput!
}

input SnapshotUpsertWithWhereUniqueWithoutStockPortfolioInput {
  create: SnapshotCreateWithoutStockPortfolioInput!
  update: SnapshotUpdateWithoutStockPortfolioDataInput!
  where: SnapshotWhereUniqueInput!
}

input SnapshotWhereInput {
  AND: [SnapshotWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [SnapshotWhereInput!]
  OR: [SnapshotWhereInput!]
  stockPortfolio: StockPortfolioWhereInput
  stockPortfolioId: StringFilter
}

input SnapshotWhereUniqueInput {
  id: String!
}

"""
The data for a stock-portfolio, derived from its headers and tickers. Accessing the `data` prop of this type will incur a transaction for the `viewer` of this request
"""
type StockData {
  """
  The data for this stock-portfolio. Accessing this property incurs a transaction for the viewer of this request
  """
  data: [JSONObject!]

  """The amount in credits, that a data-refresh would cost"""
  refreshCost(enableSnapshots: Boolean): Int!

  """
  The stock portfolio for which this data is being generated for. If provided, 				snapshots may be created depending on the stock-portfolio's settings.
  """
  stockPortfolio: StockPortfolio!
}

type StockDataSearch {
  exchange: String!
  region: String!
  securityName: String!
  securityType: String!
  symbol: String!
}

input StockDataWhereUniqueInput {
  stockPortfolioId: String!
}

"""StockPortfolio entity. This is what gets shown on the data grid"""
type StockPortfolio {
  createdAt: DateTime!
  headers: [StockPortfolioHeader!]!
  id: String!
  name: String!
  settings: StockPortfolioSettings!
  snapshots: [Snapshot!]!

  """The data that gets resolved based on headers and tickers"""
  stockData: StockData!
  tickers: [String!]!
  updatedAt: DateTime!
  user: User!
}

input StockPortfolioCreateheadersInput {
  set: [String!]
}

input StockPortfolioCreateInput {
  name: String!
}

input StockPortfolioCreateManyWithoutUserInput {
  connect: [StockPortfolioWhereUniqueInput!]
  create: [StockPortfolioCreateWithoutUserInput!]
}

input StockPortfolioCreateOneWithoutStockPortfolioEventInput {
  connect: StockPortfolioWhereUniqueInput!
}

input StockPortfolioCreateOneWithoutWebhookInput {
  connect: StockPortfolioWhereUniqueInput!
}

input StockPortfolioCreatetickersInput {
  set: [String!]
}

input StockPortfolioCreateWithoutStockPortfolioEventInput {
  createdAt: DateTime
  headers: StockPortfolioCreateheadersInput
  id: String
  name: String!
  settings: StockPortfolioSettingsCreateOneWithoutStockPortfolioInput!
  snapshot: SnapshotCreateManyWithoutStockPortfolioInput
  tickers: StockPortfolioCreatetickersInput
  updatedAt: DateTime
  user: UserCreateOneWithoutStockPortfolioInput!
  webhook: WebhookCreateManyWithoutStockPortfolioInput
}

input StockPortfolioCreateWithoutUserInput {
  createdAt: DateTime
  headers: StockPortfolioCreateheadersInput
  id: String
  name: String!
  settings: StockPortfolioSettingsCreateOneWithoutStockPortfolioInput!
  snapshot: SnapshotCreateManyWithoutStockPortfolioInput
  stockPortfolioEvent: StockPortfolioEventCreateManyWithoutStockPortfolioInput
  tickers: StockPortfolioCreatetickersInput
  updatedAt: DateTime
  webhook: WebhookCreateManyWithoutStockPortfolioInput
}

interface StockPortfolioDataHeader {
  dataKey: String!
  name: String!
}

type StockPortfolioEvent {
  scheduledEvent: ScheduledEvent!
  scheduledEventId: String!
  stockPortfolio: StockPortfolio!
  type: StockPortfolioEventType!
}

input StockPortfolioEventCreateInput {
  scheduledEvent: ScheduledEventCreateOneWithoutStockPortfolioEventInput!
  stockPortfolio: StockPortfolioCreateOneWithoutStockPortfolioEventInput!
  type: StockPortfolioEventType!
}

input StockPortfolioEventCreateManyWithoutScheduledEventInput {
  connect: [StockPortfolioEventWhereUniqueInput!]
  create: [StockPortfolioEventCreateWithoutScheduledEventInput!]
}

input StockPortfolioEventCreateManyWithoutStockPortfolioInput {
  connect: [StockPortfolioEventWhereUniqueInput!]
  create: [StockPortfolioEventCreateWithoutStockPortfolioInput!]
}

input StockPortfolioEventCreateWithoutScheduledEventInput {
  stockPortfolio: StockPortfolioCreateOneWithoutStockPortfolioEventInput!
  type: StockPortfolioEventType!
}

input StockPortfolioEventCreateWithoutStockPortfolioInput {
  scheduledEvent: ScheduledEventCreateOneWithoutStockPortfolioEventInput!
  type: StockPortfolioEventType!
}

input StockPortfolioEventFilter {
  every: StockPortfolioEventWhereInput
  none: StockPortfolioEventWhereInput
  some: StockPortfolioEventWhereInput
}

input StockPortfolioEventScalarWhereInput {
  AND: [StockPortfolioEventScalarWhereInput!]
  NOT: [StockPortfolioEventScalarWhereInput!]
  OR: [StockPortfolioEventScalarWhereInput!]
  scheduledEventId: StringFilter
  stockPortfolioId: StringFilter
  type: StockPortfolioEventType
}

enum StockPortfolioEventType {
  DataRetrieved
}

input StockPortfolioEventUpdateInput {
  scheduledEvent: ScheduledEventUpdateOneRequiredWithoutStockPortfolioEventInput
  stockPortfolio: StockPortfolioUpdateOneRequiredWithoutStockPortfolioEventInput
  type: StockPortfolioEventType
}

input StockPortfolioEventUpdateManyDataInput {
  type: StockPortfolioEventType
}

input StockPortfolioEventUpdateManyWithoutScheduledEventInput {
  connect: [StockPortfolioEventWhereUniqueInput!]
  create: [StockPortfolioEventCreateWithoutScheduledEventInput!]
  delete: [StockPortfolioEventWhereUniqueInput!]
  deleteMany: [StockPortfolioEventScalarWhereInput!]
  disconnect: [StockPortfolioEventWhereUniqueInput!]
  set: [StockPortfolioEventWhereUniqueInput!]
  update: [StockPortfolioEventUpdateWithWhereUniqueWithoutScheduledEventInput!]
  updateMany: [StockPortfolioEventUpdateManyWithWhereNestedInput!]
  upsert: [StockPortfolioEventUpsertWithWhereUniqueWithoutScheduledEventInput!]
}

input StockPortfolioEventUpdateManyWithoutStockPortfolioInput {
  connect: [StockPortfolioEventWhereUniqueInput!]
  create: [StockPortfolioEventCreateWithoutStockPortfolioInput!]
  delete: [StockPortfolioEventWhereUniqueInput!]
  deleteMany: [StockPortfolioEventScalarWhereInput!]
  disconnect: [StockPortfolioEventWhereUniqueInput!]
  set: [StockPortfolioEventWhereUniqueInput!]
  update: [StockPortfolioEventUpdateWithWhereUniqueWithoutStockPortfolioInput!]
  updateMany: [StockPortfolioEventUpdateManyWithWhereNestedInput!]
  upsert: [StockPortfolioEventUpsertWithWhereUniqueWithoutStockPortfolioInput!]
}

input StockPortfolioEventUpdateManyWithWhereNestedInput {
  data: StockPortfolioEventUpdateManyDataInput!
  where: StockPortfolioEventScalarWhereInput!
}

input StockPortfolioEventUpdateWithoutScheduledEventDataInput {
  stockPortfolio: StockPortfolioUpdateOneRequiredWithoutStockPortfolioEventInput
  type: StockPortfolioEventType
}

input StockPortfolioEventUpdateWithoutStockPortfolioDataInput {
  scheduledEvent: ScheduledEventUpdateOneRequiredWithoutStockPortfolioEventInput
  type: StockPortfolioEventType
}

input StockPortfolioEventUpdateWithWhereUniqueWithoutScheduledEventInput {
  data: StockPortfolioEventUpdateWithoutScheduledEventDataInput!
  where: StockPortfolioEventWhereUniqueInput!
}

input StockPortfolioEventUpdateWithWhereUniqueWithoutStockPortfolioInput {
  data: StockPortfolioEventUpdateWithoutStockPortfolioDataInput!
  where: StockPortfolioEventWhereUniqueInput!
}

input StockPortfolioEventUpsertWithWhereUniqueWithoutScheduledEventInput {
  create: StockPortfolioEventCreateWithoutScheduledEventInput!
  update: StockPortfolioEventUpdateWithoutScheduledEventDataInput!
  where: StockPortfolioEventWhereUniqueInput!
}

input StockPortfolioEventUpsertWithWhereUniqueWithoutStockPortfolioInput {
  create: StockPortfolioEventCreateWithoutStockPortfolioInput!
  update: StockPortfolioEventUpdateWithoutStockPortfolioDataInput!
  where: StockPortfolioEventWhereUniqueInput!
}

input StockPortfolioEventWhereInput {
  AND: [StockPortfolioEventWhereInput!]
  NOT: [StockPortfolioEventWhereInput!]
  OR: [StockPortfolioEventWhereInput!]
  scheduledEvent: ScheduledEventWhereInput
  scheduledEventId: StringFilter
  stockPortfolio: StockPortfolioWhereInput
  stockPortfolioId: StringFilter
  type: StockPortfolioEventType
}

input StockPortfolioEventWhereUniqueInput {
  scheduledEventId: String
  stockPortfolioId_type: StockPortfolioIdTypeCompoundUniqueInput
}

input StockPortfolioFilter {
  every: StockPortfolioWhereInput
  none: StockPortfolioWhereInput
  some: StockPortfolioWhereInput
}

type StockPortfolioHeader implements StockPortfolioDataHeader {
  dataKey: String!
  frozen: Boolean!
  name: String!
  resizable: Boolean!
  width: Int!
}

input StockPortfolioHeaderInput {
  dataKey: String!
  frozen: Boolean!
  name: String!
  resizable: Boolean!
  width: Int!
}

input StockPortfolioIdNameCompoundUniqueInput {
  name: String!
  stockPortfolioId: String!
}

input StockPortfolioIdTypeCompoundUniqueInput {
  stockPortfolioId: String!
  type: StockPortfolioEventType!
}

input StockPortfolioOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
  userId: OrderByArg
}

input StockPortfolioScalarWhereInput {
  AND: [StockPortfolioScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [StockPortfolioScalarWhereInput!]
  OR: [StockPortfolioScalarWhereInput!]
  snapshot: SnapshotFilter
  stockPortfolioEvent: StockPortfolioEventFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
  webhook: WebhookFilter
}

type StockPortfolioSettings {
  enableSnapshots: Boolean!
  pollInterval: Int!
  stockPortfolio: StockPortfolio!
}

input StockPortfolioSettingsCreateOneWithoutStockPortfolioInput {
  connect: StockPortfolioSettingsWhereUniqueInput
  create: StockPortfolioSettingsCreateWithoutStockPortfolioInput
}

input StockPortfolioSettingsCreateWithoutStockPortfolioInput {
  enableSnapshots: Boolean
  pollInterval: Int
}

input StockPortfolioSettingsUpdateInput {
  """
  Whether snapshots should be saved per-data-refresh of this stock-portfolio
  """
  enableSnapshots: Boolean

  """
  The time, in minutes, for when more data should be fetched for the stock-portfolio
  """
  pollInterval: Int
}

input StockPortfolioSettingsUpdateOneRequiredWithoutStockPortfolioInput {
  connect: StockPortfolioSettingsWhereUniqueInput
  create: StockPortfolioSettingsCreateWithoutStockPortfolioInput
  update: StockPortfolioSettingsUpdateWithoutStockPortfolioDataInput
  upsert: StockPortfolioSettingsUpsertWithoutStockPortfolioInput
}

input StockPortfolioSettingsUpdateWithoutStockPortfolioDataInput {
  enableSnapshots: Boolean
  pollInterval: Int
}

input StockPortfolioSettingsUpsertWithoutStockPortfolioInput {
  create: StockPortfolioSettingsCreateWithoutStockPortfolioInput!
  update: StockPortfolioSettingsUpdateWithoutStockPortfolioDataInput!
}

input StockPortfolioSettingsWhereInput {
  AND: [StockPortfolioSettingsWhereInput!]
  enableSnapshots: BooleanFilter
  NOT: [StockPortfolioSettingsWhereInput!]
  OR: [StockPortfolioSettingsWhereInput!]
  pollInterval: IntFilter
  stockPortfolio: StockPortfolioWhereInput
  stockPortfolioId: StringFilter
}

input StockPortfolioSettingsWhereUniqueInput {
  stockPortfolioId: String!
}

input StockPortfolioUpdateheadersInput {
  set: [String!]
}

input StockPortfolioUpdateInput {
  headers: [StockPortfolioHeaderInput!]
  name: String
  tickers: [String!]
}

input StockPortfolioUpdateManyDataInput {
  createdAt: DateTime
  headers: StockPortfolioUpdateheadersInput
  id: String
  name: String
  tickers: StockPortfolioUpdatetickersInput
  updatedAt: DateTime
}

input StockPortfolioUpdateManyWithoutUserInput {
  connect: [StockPortfolioWhereUniqueInput!]
  create: [StockPortfolioCreateWithoutUserInput!]
  delete: [StockPortfolioWhereUniqueInput!]
  deleteMany: [StockPortfolioScalarWhereInput!]
  disconnect: [StockPortfolioWhereUniqueInput!]
  set: [StockPortfolioWhereUniqueInput!]
  update: [StockPortfolioUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [StockPortfolioUpdateManyWithWhereNestedInput!]
  upsert: [StockPortfolioUpsertWithWhereUniqueWithoutUserInput!]
}

input StockPortfolioUpdateManyWithWhereNestedInput {
  data: StockPortfolioUpdateManyDataInput!
  where: StockPortfolioScalarWhereInput!
}

input StockPortfolioUpdateOneRequiredWithoutStockPortfolioEventInput {
  connect: StockPortfolioWhereUniqueInput
  create: StockPortfolioCreateWithoutStockPortfolioEventInput
  update: StockPortfolioUpdateWithoutStockPortfolioEventDataInput
  upsert: StockPortfolioUpsertWithoutStockPortfolioEventInput
}

input StockPortfolioUpdatetickersInput {
  set: [String!]
}

input StockPortfolioUpdateWithoutStockPortfolioEventDataInput {
  createdAt: DateTime
  headers: StockPortfolioUpdateheadersInput
  id: String
  name: String
  settings: StockPortfolioSettingsUpdateOneRequiredWithoutStockPortfolioInput
  snapshot: SnapshotUpdateManyWithoutStockPortfolioInput
  tickers: StockPortfolioUpdatetickersInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutStockPortfolioInput
  webhook: WebhookUpdateManyWithoutStockPortfolioInput
}

input StockPortfolioUpdateWithoutUserDataInput {
  createdAt: DateTime
  headers: StockPortfolioUpdateheadersInput
  id: String
  name: String
  settings: StockPortfolioSettingsUpdateOneRequiredWithoutStockPortfolioInput
  snapshot: SnapshotUpdateManyWithoutStockPortfolioInput
  stockPortfolioEvent: StockPortfolioEventUpdateManyWithoutStockPortfolioInput
  tickers: StockPortfolioUpdatetickersInput
  updatedAt: DateTime
  webhook: WebhookUpdateManyWithoutStockPortfolioInput
}

input StockPortfolioUpdateWithWhereUniqueWithoutUserInput {
  data: StockPortfolioUpdateWithoutUserDataInput!
  where: StockPortfolioWhereUniqueInput!
}

input StockPortfolioUpsertWithoutStockPortfolioEventInput {
  create: StockPortfolioCreateWithoutStockPortfolioEventInput!
  update: StockPortfolioUpdateWithoutStockPortfolioEventDataInput!
}

input StockPortfolioUpsertWithWhereUniqueWithoutUserInput {
  create: StockPortfolioCreateWithoutUserInput!
  update: StockPortfolioUpdateWithoutUserDataInput!
  where: StockPortfolioWhereUniqueInput!
}

input StockPortfolioWhereInput {
  AND: [StockPortfolioWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [StockPortfolioWhereInput!]
  OR: [StockPortfolioWhereInput!]
  settings: StockPortfolioSettingsWhereInput
  snapshot: SnapshotFilter
  stockPortfolioEvent: StockPortfolioEventFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  webhook: WebhookFilter
}

input StockPortfolioWhereUniqueInput {
  id: String
  userId_name: UserIdNameCompoundUniqueInput
}

input StockPortfolioWhereWithoutUserInput {
  AND: [StockPortfolioWhereWithoutUserInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [StockPortfolioWhereWithoutUserInput!]
  OR: [StockPortfolioWhereWithoutUserInput!]
  updatedAt: DateTimeFilter
  webhook: WebhookFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type StripeCard {
  brand: String!
  exp_month: Int!
  exp_year: Int!
  fingerprint: String
  last4: String!
}

input StripeDetailsCreateManyWithoutUserInput {
  connect: [StripeDetailsWhereUniqueInput!]
  create: [StripeDetailsCreateWithoutUserInput!]
}

input StripeDetailsCreateWithoutUserInput {
  customerId: String!
}

input StripeDetailsFilter {
  every: StripeDetailsWhereInput
  none: StripeDetailsWhereInput
  some: StripeDetailsWhereInput
}

input StripeDetailsScalarWhereInput {
  AND: [StripeDetailsScalarWhereInput!]
  customerId: StringFilter
  NOT: [StripeDetailsScalarWhereInput!]
  OR: [StripeDetailsScalarWhereInput!]
  userId: StringFilter
}

input StripeDetailsUpdateManyDataInput {
  customerId: String
}

input StripeDetailsUpdateManyWithoutUserInput {
  connect: [StripeDetailsWhereUniqueInput!]
  create: [StripeDetailsCreateWithoutUserInput!]
  delete: [StripeDetailsWhereUniqueInput!]
  deleteMany: [StripeDetailsScalarWhereInput!]
  disconnect: [StripeDetailsWhereUniqueInput!]
  set: [StripeDetailsWhereUniqueInput!]
  update: [StripeDetailsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [StripeDetailsUpdateManyWithWhereNestedInput!]
  upsert: [StripeDetailsUpsertWithWhereUniqueWithoutUserInput!]
}

input StripeDetailsUpdateManyWithWhereNestedInput {
  data: StripeDetailsUpdateManyDataInput!
  where: StripeDetailsScalarWhereInput!
}

input StripeDetailsUpdateWithoutUserDataInput {
  customerId: String
}

input StripeDetailsUpdateWithWhereUniqueWithoutUserInput {
  data: StripeDetailsUpdateWithoutUserDataInput!
  where: StripeDetailsWhereUniqueInput!
}

input StripeDetailsUpsertWithWhereUniqueWithoutUserInput {
  create: StripeDetailsCreateWithoutUserInput!
  update: StripeDetailsUpdateWithoutUserDataInput!
  where: StripeDetailsWhereUniqueInput!
}

input StripeDetailsWhereInput {
  AND: [StripeDetailsWhereInput!]
  customerId: StringFilter
  NOT: [StripeDetailsWhereInput!]
  OR: [StripeDetailsWhereInput!]
  user: UserWhereInput
  userId: StringFilter
}

input StripeDetailsWhereUniqueInput {
  customerId: String
  userId: String
}

type StripePaymentIntent {
  amount: Float
  client_secret: String
  created: Int!
  currency: String
  id: String!
  payment_method: StripePaymentMethod
}

type StripePaymentMethod {
  card: StripeCard
  created: Int!
  id: String!
}

type StripeSetupIntent {
  client_secret: String
  created: Int!
  id: String!
  payment_method: StripePaymentMethod
}

"""The response from a successful login or token refresh request"""
type TokenPayload {
  """JSON web token to refresh the token"""
  refreshToken: String!

  """JSON web token to authenticate API requests"""
  token: String!
}

type Transaction {
  creditsBefore: Int!
  creditsTransacted: Int!
  id: String!
  paymentIntent: StripePaymentIntent
  paymentIntentId: String
  user: User!
}

input TransactionCreateManyWithoutUserInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutUserInput!]
}

input TransactionCreateWithoutUserInput {
  createdAt: DateTime
  creditsBefore: Int!
  creditsTransacted: Int!
  id: String
  paymentIntentId: String
  status: TransactionStatus
}

input TransactionFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionOrderByInput {
  createdAt: OrderByArg
  creditsBefore: OrderByArg
  creditsTransacted: OrderByArg
}

input TransactionScalarWhereInput {
  AND: [TransactionScalarWhereInput!]
  createdAt: DateTimeFilter
  creditsBefore: IntFilter
  creditsTransacted: IntFilter
  id: StringFilter
  NOT: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  paymentIntentId: NullableStringFilter
  status: TransactionStatus
  userId: StringFilter
}

enum TransactionStatus {
  FAILED
  PENDING
  SUCCEEDED
}

input TransactionUpdateManyDataInput {
  createdAt: DateTime
  creditsBefore: Int
  creditsTransacted: Int
  id: String
  paymentIntentId: String
  status: TransactionStatus
}

input TransactionUpdateManyWithoutUserInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutUserInput!]
  delete: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutUserInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  data: TransactionUpdateManyDataInput!
  where: TransactionScalarWhereInput!
}

input TransactionUpdateWithoutUserDataInput {
  createdAt: DateTime
  creditsBefore: Int
  creditsTransacted: Int
  id: String
  paymentIntentId: String
  status: TransactionStatus
}

input TransactionUpdateWithWhereUniqueWithoutUserInput {
  data: TransactionUpdateWithoutUserDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpsertWithWhereUniqueWithoutUserInput {
  create: TransactionCreateWithoutUserInput!
  update: TransactionUpdateWithoutUserDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  createdAt: DateTimeFilter
  creditsBefore: IntFilter
  creditsTransacted: IntFilter
  id: StringFilter
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  paymentIntentId: NullableStringFilter
  status: TransactionStatus
  user: UserWhereInput
  userId: StringFilter
}

input TransactionWhereUniqueInput {
  id: String
  paymentIntentId: String
}

input TransactionWhereWithoutUserInput {
  AND: [TransactionWhereWithoutUserInput!]
  createdAt: DateTimeFilter
  creditsBefore: IntFilter
  creditsTransacted: IntFilter
  id: StringFilter
  NOT: [TransactionWhereWithoutUserInput!]
  OR: [TransactionWhereWithoutUserInput!]
  paymentIntentId: NullableStringFilter
  status: TransactionStatus
}

"""Basic user of the application"""
type User {
  balance: Balance
  createdAt: DateTime!
  email: EmailAddress!
  emailVerified: Boolean!
  id: String!
  updatedAt: DateTime!
  username: String!
}

input UserCreateOneWithoutStockPortfolioInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutStockPortfolioInput
}

input UserCreateWithoutScheduledEventInput {
  balance: BalanceCreateManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: Boolean
  id: String
  password: String!
  stockPortfolio: StockPortfolioCreateManyWithoutUserInput
  stripeDetails: StripeDetailsCreateManyWithoutUserInput
  transaction: TransactionCreateManyWithoutUserInput
  updatedAt: DateTime
  username: String!
}

input UserCreateWithoutStockPortfolioInput {
  balance: BalanceCreateManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: Boolean
  id: String
  password: String!
  scheduledEvent: ScheduledEventCreateManyWithoutUserInput
  stripeDetails: StripeDetailsCreateManyWithoutUserInput
  transaction: TransactionCreateManyWithoutUserInput
  updatedAt: DateTime
  username: String!
}

input UserIdNameCompoundUniqueInput {
  name: String!
  userId: String!
}

"""The plain-text password of a user to be hashed"""
scalar UserPassword

input UserUpdateOneRequiredWithoutScheduledEventInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutScheduledEventInput
  update: UserUpdateWithoutScheduledEventDataInput
  upsert: UserUpsertWithoutScheduledEventInput
}

input UserUpdateOneRequiredWithoutStockPortfolioInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutStockPortfolioInput
  update: UserUpdateWithoutStockPortfolioDataInput
  upsert: UserUpsertWithoutStockPortfolioInput
}

input UserUpdateWithoutScheduledEventDataInput {
  balance: BalanceUpdateManyWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: Boolean
  id: String
  password: String
  stockPortfolio: StockPortfolioUpdateManyWithoutUserInput
  stripeDetails: StripeDetailsUpdateManyWithoutUserInput
  transaction: TransactionUpdateManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserUpdateWithoutStockPortfolioDataInput {
  balance: BalanceUpdateManyWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: Boolean
  id: String
  password: String
  scheduledEvent: ScheduledEventUpdateManyWithoutUserInput
  stripeDetails: StripeDetailsUpdateManyWithoutUserInput
  transaction: TransactionUpdateManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

input UserUpsertWithoutScheduledEventInput {
  create: UserCreateWithoutScheduledEventInput!
  update: UserUpdateWithoutScheduledEventDataInput!
}

input UserUpsertWithoutStockPortfolioInput {
  create: UserCreateWithoutStockPortfolioInput!
  update: UserUpdateWithoutStockPortfolioDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  balance: BalanceFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: BooleanFilter
  id: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  scheduledEvent: ScheduledEventFilter
  stockPortfolio: StockPortfolioFilter
  stripeDetails: StripeDetailsFilter
  transaction: TransactionFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  username: String
}

type Webhook {
  createdAt: DateTime!
  id: String!
  name: String!
  stockPortfolio: StockPortfolio!
  timeout: Int!
  type: WebhookType!
  url: String!
}

input WebhookCreateInput {
  name: String!
  stockPortfolio: StockPortfolioCreateOneWithoutWebhookInput!
  timeout: Int
  type: WebhookType!
  url: String!
}

input WebhookCreateManyWithoutStockPortfolioInput {
  connect: [WebhookWhereUniqueInput!]
  create: [WebhookCreateWithoutStockPortfolioInput!]
}

input WebhookCreateWithoutStockPortfolioInput {
  createdAt: DateTime
  id: String
  name: String!
  timeout: Int
  type: WebhookType!
  url: String!
}

input WebhookFilter {
  every: WebhookWhereInput
  none: WebhookWhereInput
  some: WebhookWhereInput
}

input WebhookOrderByInput {
  createdAt: OrderByArg
  name: OrderByArg
}

input WebhookScalarWhereInput {
  AND: [WebhookScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [WebhookScalarWhereInput!]
  OR: [WebhookScalarWhereInput!]
  stockPortfolioId: StringFilter
  timeout: IntFilter
  type: WebhookType
  url: StringFilter
}

enum WebhookType {
  StockDataRetrieved
}

input WebhookUpdateInput {
  name: String
  timeout: Int
  type: WebhookType
  url: String
}

input WebhookUpdateManyDataInput {
  createdAt: DateTime
  id: String
  name: String
  timeout: Int
  type: WebhookType
  url: String
}

input WebhookUpdateManyWithoutStockPortfolioInput {
  connect: [WebhookWhereUniqueInput!]
  create: [WebhookCreateWithoutStockPortfolioInput!]
  delete: [WebhookWhereUniqueInput!]
  deleteMany: [WebhookScalarWhereInput!]
  disconnect: [WebhookWhereUniqueInput!]
  set: [WebhookWhereUniqueInput!]
  update: [WebhookUpdateWithWhereUniqueWithoutStockPortfolioInput!]
  updateMany: [WebhookUpdateManyWithWhereNestedInput!]
  upsert: [WebhookUpsertWithWhereUniqueWithoutStockPortfolioInput!]
}

input WebhookUpdateManyWithWhereNestedInput {
  data: WebhookUpdateManyDataInput!
  where: WebhookScalarWhereInput!
}

input WebhookUpdateWithoutStockPortfolioDataInput {
  createdAt: DateTime
  id: String
  name: String
  timeout: Int
  type: WebhookType
  url: String
}

input WebhookUpdateWithWhereUniqueWithoutStockPortfolioInput {
  data: WebhookUpdateWithoutStockPortfolioDataInput!
  where: WebhookWhereUniqueInput!
}

input WebhookUpsertWithWhereUniqueWithoutStockPortfolioInput {
  create: WebhookCreateWithoutStockPortfolioInput!
  update: WebhookUpdateWithoutStockPortfolioDataInput!
  where: WebhookWhereUniqueInput!
}

input WebhookWhereInput {
  AND: [WebhookWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [WebhookWhereInput!]
  OR: [WebhookWhereInput!]
  stockPortfolio: StockPortfolioWhereWithoutUserInput
  stockPortfolioId: StringFilter
  timeout: IntFilter
  type: WebhookType
  url: StringFilter
}

input WebhookWhereUniqueInput {
  id: String
  stockPortfolioId_name: StockPortfolioIdNameCompoundUniqueInput
}
